<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <img src="./img/599584-15f617d44cdb990d.png" alt="">
    <script>
        /* 
        JavaScript的学习零散而庞杂，因此很多时候我们学到了一些东西，但是却没办法感受到自己的进步，
        甚至过了不久，就把学到的东西给忘了。
        为了解决自己的这个困扰，在学习的过程中，我一直试图在寻找一条核心的线索，
        只要我根据这条线索，我就能够一点一点的进步。

        前端基础进阶正是围绕这条线索慢慢展开，而事件循环机制(Event Loop)，则是这条线索的最关键的知识点。
        所以，我就马不停蹄的去深入的学习了事件循环机制，并总结出了这篇文章跟大家分享。

        事件循环机制从整体上的告诉了我们所写的JavaScript代码的执行顺序。
        但是在我学习的过程中，找到的许多国内博客文章对于它的讲解浅尝辄止，不得其法，
        很多文章在图中画个圈就表示循环了，看了之后也没感觉明白了多少。
        但是他又如此重要，以致于当我们想要面试中高级岗位时，事件循环机制总是绕不开的话题。
        特别是ES6中正式加入了Promise对象之后，对于新标准中事件循环机制的理解就变得更加重要。这就很尴尬了。


        在学习事件循环机制之前，我默认你已经懂得了如下概念，如果仍然有疑问，可以回过头去看看我以前的文章。
        1.执行上下文(Execution context)
        2.函数调用栈(call stack)
        3.队列数据结构(queue)
        4.Promise(我会在下一篇文章专门总结Promise的详细使用)

        因为chrome浏览器中新标准中的事件循环机制与nodejs类似，因此此处就整合nodejs一起来理解，
        其中会介绍到几个nodejs有，但是浏览器中没有的API，大家只需要了解就好，不一定非要知道她是如何使用。
        比如process.nextTick，setImmediate


        OK，那我就先抛出结论，然后以例子与图示详细给大家演示事件循环机制。

        1.我们知道JavaScript的一大特点就是单线程，而这个线程中拥有唯一的一个事件循环。
        (当然新标准中的web worker涉及到了多线程，我对它了解也不多，这里就不讨论了。)

        2.JavaScript代码的执行过程中，除了依靠函数调用栈来搞定函数的执行顺序外，
        还依靠任务队列(task queue)来搞定另外一些代码的执行。

        3.一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。

        4.任务队列又分为macro-task（宏任务）与micro-task（微任务），在最新标准中，它们被分别称为task与jobs。

        5.macro-task大概包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。

        6.micro-task大概包括: process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5新特性)

        7.setTimeout/Promise等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务。
        // setTimeout中的回调函数才是进入任务队列的任务
        setTimeout(function() {
            console.log('xxxx');
        })
        // 非常多的同学对于setTimeout的理解存在偏差。所以大概说一下误解：
        // setTimeout作为一个任务分发器，这个函数会立即执行，而它所要分发的任务，也就是它的第一个参数，才是延迟执行

        8.来自不同任务源的任务会进入到不同的任务队列。其中setTimeout与setInterval是同源的。

        9.事件循环的顺序，决定了JavaScript代码的执行顺序。
        它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。
        直到调用栈清空(只剩全局)，然后执行所有的micro-task。
        当所有可执行的micro-task执行完毕之后。
        循环再次从macro-task开始，找到其中一个任务队列执行完毕，
        然后再执行所有的micro-task，这样一直循环下去。

        10.其中每一个任务的执行，无论是macro-task还是micro-task，都是借助函数调用栈来完成。




        */
    </script>
</body>

</html>