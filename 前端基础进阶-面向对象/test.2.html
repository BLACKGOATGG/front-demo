<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        // 二、工厂模式
        // 使用上面的方式创建对象很简单，但是在很多时候并不能满足我们的需求。

        // 就以person对象为例。假如我们在实际开发中，不仅仅需要一个名字叫做TOM的person对象，同时还需要另外一个名为Jake的person对象，
        // 虽然他们有很多相似之处，但是我们不得不重复写两次。
        var perTom = {
            name: 'TOM',
            age: 20,
            getName: function() {
                return this.name
            }
        };

        var perJake = {
            name: 'Jake',
            age: 22,
            getName: function() {
                return this.name
            }
        }

        // 很显然这并不是合理的方式，当相似对象太多时，大家都会崩溃掉。

        // 我们可以使用工厂模式的方式解决这个问题。

        // 顾名思义，工厂模式就是我们提供一个模子，然后通过这个模子复制出我们需要的对象。
        // 我们需要多少个，就复制多少个。
        var createPerson = function(name, age) {
            // 声明一个中间对象，该对象就是工厂模式的模子
            var o = new Object();
            // 依次添加我们需要的属性与方法
            o.name = name;
            o.age = age;
            o.getName = function() {
                return this.name;
            }
            return o;
        }

        // 创建两个实例
        var perTom = createPerson('TOM', 20);
        var PerJake = createPerson('Jake', 22);

        // 相信上面的代码并不难理解，也不用把工厂模式看得太过高大上。
        // 很显然，工厂模式帮助我们解决了重复代码上的麻烦，让我们可以写很少的代码，就能够创建很多个person对象。


        // ===========================================================================================
        // 但是这里还有两个麻烦，需要我们注意。

        // 第一个麻烦就是这样处理，我们没有办法识别对象实例的类型。
        // 使用instanceof可以识别对象的类型，如下例子：

        var obj = {};
        var foo = function() {}

        console.log(obj instanceof Object);  // true
        console.log(foo instanceof Function); // true
        // 因此在工厂模式的基础上，我们需要使用构造函数的方式来解决这个麻烦。

    </script>
</body>

</html>